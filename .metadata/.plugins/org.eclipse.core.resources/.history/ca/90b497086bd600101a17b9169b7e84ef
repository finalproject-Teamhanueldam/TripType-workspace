package com.kh.backend.common.interceptor;

import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.Date;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import com.kh.backend.auth.controller.AuthController;
import com.kh.backend.auth.model.service.AuthService;
import com.kh.backend.member.model.vo.Member;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtParser;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AuthInterceptor implements HandlerInterceptor {
	
	// AuthServiceImpl 객체 받아오기
	@Autowired
	private AuthService authService;

	// 요청 전에 제대로된 사용자인지 (관리자인지) 를 검증해야 하기 때문에 preHandle
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		
		// System.out.println("잘 호출되나?");
		
		// 인가 기능 구현 시 JWT 토큰값을 "티켓" 이라고 생각하자!!
		// > 이 티켓이 제대로된 놈이냐 아니냐에 따라 return true / false;
		// > 리액트 코드에서 모든 요청 시 전달값에 JWT 토큰값도 같이 넘길것임!!
		
		// URL 주소로부터 Header 영역에 담긴 인증 토큰 (JWT) 값을 뽑기
		String authHeader = request.getHeader("Authorization");
		
		// System.out.println(authHeader);
		// > 토큰이 제대로 전달된 경우 "Bearer eyJhbGci...."
		//   토큰이 제대로 전달되지 않은 경우 "Bearer null" 또는 null 또는 ""
		
		// 우선 제대로 된 토큰값이 전달됬는지 검사
		if((authHeader != null) && 
				(!authHeader.equals("")) && 
				(authHeader.startsWith("Bearer "))) {
			// > 문자열.startsWith("시작문자열") : 문자열이 해당 시작문자열로 시작하면 true 반환
			
			// 이 시점 기준으로 토큰이 제대로 전달되었을 경우 이 if 문 안으로 들어옴
			// > "Bearer eyJhbGci...." 또는 "Bearer xxxxx..." 또는 "Bearer null"
			
			// "Bearer " 라는 접두어를 없애기
			String jwtTokenString = authHeader.substring(7);
			
			// System.out.println(jwtTokenString);
			log.debug(jwtTokenString);
			// > "eyJhbGci...." 또는 "xxxxx..." 또는 "null"
			
			// 이 추출해낸 문자열 값을 가지고 대조 작업 진행
			// 1. JWT 발급 시 썼었던 비밀 키를 똑같은 형태의 Key 객체로 가공하기
			Key key = Keys.hmacShaKeyFor(AuthController.secretKey.getBytes(StandardCharsets.UTF_8));
			// > 아까 암호화했을 때 쓴 키를 복호화할 때도 똑같이 쓴다. (대칭키)
			
			// 2. 위에서 얻어낸 Key 객체를 가지고 jwtTokenString 문자열을 풀어주기 (해석, 파싱)
			JwtParser parser = Jwts.parserBuilder()
								   .setSigningKey(key)
								   .build();
			
			Claims claims = parser.parseClaimsJws(jwtTokenString).getBody();
			// > claims 객체에는 최종적으로 Payload 에 담겨있던 데이터들이 넘어옴
			
			// 담겨있는 데이터를 검증하기
			if(!claims.getExpiration().before(new Date())) {
				// > claims.getExpiration() 만료시간을 뽑아주는 메소드
				//   만료시간.before(현재시간) : 만료시간이 현재시간 보다 이전입니까? - 만료된 토큰
				//   !만료시간.before(현재시간) : 만료시간이 현재시간 보다 이후입니까? - 유효한 토큰
				
				// > 이 시점 기준으로 유효한 토큰임 (만료시간만 따졌을때)
				
				// claims 에서 아이디값을 추출해서 비교 (아이디는 PK 이므로)
				// > DB 로 부터 회원 아이디로 회원 정보를 조회해오기
				//   기존 로그인 서비스 로직 재활용하기
				String userId = claims.getSubject();
				
				Member m = authService.loginAdmin(userId);
				// > selectOne 에 의해 제대로 조회되면 Member 객체가 담겨올거고, 제대로 조회되지 않으면 null
				
				// System.out.println(userId);
				// System.out.println(m);
				log.debug("요청한 회원의 아이디 : {}", userId);
				
				if((userId != null) && 
						(m != null) && 
						(userId.equals(m.getUserId()))) {
					
					// > 유효한 토큰이라면 (회원이라면)
					return true;
					
				}
				
			}
			
		}
		
		return false;
		// 그 외의 다른 모든 경우의 수는 return false; 
		// > Controller 로 요청이 들어갈 수 없음!!
		
	}
	
}
